-- Migration: Add Distributed Systems chapters (8-14) and fill missing content
-- Run with: wrangler d1 execute gtl-db --remote --file=./src/db/migrations/005-fishbook-distributed-systems.sql

-- Create new modules for chapters 8-14
INSERT INTO modules (project_id, name, sort_order) VALUES
  ((SELECT id FROM projects WHERE name = 'Database Internals'), 'Chapter 8: Introduction and Overview (Distributed Systems)', 8),
  ((SELECT id FROM projects WHERE name = 'Database Internals'), 'Chapter 9: Failure Detection', 9),
  ((SELECT id FROM projects WHERE name = 'Database Internals'), 'Chapter 10: Leader Election', 10),
  ((SELECT id FROM projects WHERE name = 'Database Internals'), 'Chapter 11: Replication and Consistency', 11),
  ((SELECT id FROM projects WHERE name = 'Database Internals'), 'Chapter 12: Anti-Entropy and Dissemination', 12),
  ((SELECT id FROM projects WHERE name = 'Database Internals'), 'Chapter 13: Distributed Transactions', 13),
  ((SELECT id FROM projects WHERE name = 'Database Internals'), 'Chapter 14: Consensus', 14);

-- Add flashcards for Chapter 4 (module 6 on remote)
INSERT INTO flashcards (module_id, front, back) VALUES
  (6, 'What is a page header in B-Trees?', 'A section at the start of each page containing metadata for navigation, maintenance, and optimizations. Typically includes flags describing page contents/layout, number of cells, lower and upper offsets marking empty space, and other useful metadata.'),
  (6, 'What is a magic number in database file formats?', 'A multibyte constant value placed in file or page headers used for validation and sanity checks. It signals that a block represents a page, specifies its kind, or identifies its version. Example: 50 41 47 45 (hex for PAGE).'),
  (6, 'What are sibling links in B-Trees?', 'Forward and backward pointers stored in node headers that point to left and right sibling pages. They help locate neighboring nodes without ascending to the parent, but add complexity to split and merge operations since sibling offsets must be updated.'),
  (6, 'Why is there always one more pointer than keys in a B-Tree node?', 'B-Tree separator keys split the tree into subtrees for navigation. With N keys, you need N+1 pointers to cover all possible search ranges: one for values less than the first key, one between each consecutive pair of keys, and one for values greater than the last key.'),
  (6, 'What is the rightmost pointer problem in B-Trees?', 'Since there is always one more pointer than keys (N+1 pointers for N keys), the last pointer has no paired key. It can be stored separately in the header (like SQLite) or paired with a high key (like PostgreSQL Blink-Trees).'),
  (6, 'What is a node high key in B-Trees?', 'The maximum possible key that can be present in the subtree under a node. Used in Blink-Trees (PostgreSQL) to pair with the rightmost pointer, avoiding special-case handling. Represents the upper bound of values stored in the current subtree.'),
  (6, 'What are overflow pages?', 'Extension pages linked from a primary page to handle variable-size or oversize records that exceed max_payload_size. Multiple overflow pages can be chained together via page IDs stored in headers.'),
  (6, 'How does max_payload_size prevent page overflow?', 'By limiting how many payload bytes can be stored directly in a B-Tree node (calculated as node size / fanout), the page always reserves at least max_payload_size bytes free. Excess bytes spill to overflow pages.'),
  (6, 'Why does binary search require sorted data in B-Trees?', 'Binary search halves the search space each iteration by comparing the middle element. This only works when elements are ordered, so the algorithm knows whether to search left or right. Maintaining sorted order is essential for B-Tree efficiency.'),
  (6, 'What does a negative return value from binary search indicate?', 'The searched key was not found. The absolute value gives the insertion point - the index of the first element greater than the searched key, where the new key can be inserted to preserve order.'),
  (6, 'How does binary search work with indirection pointers?', 'Pick the middle cell offset, follow its pointer to locate the cell, compare the cell key with the searched key to decide search direction, and continue recursively until the element or insertion point is found.'),
  (6, 'What are breadcrumbs in B-Tree traversal?', 'References to nodes traversed on the path from root to leaf, stored in a stack. Used to backtrack during cascading splits (inserts) or merges (deletes) without needing persistent parent pointers.'),
  (6, 'What is the purpose of B-Tree rebalancing?', 'To postpone splits and merges by transferring elements between sibling nodes. Improves node occupancy, potentially reduces tree height, and leads to more efficient searches at the cost of additional maintenance logic.'),
  (6, 'How do B*-Trees differ from standard B-Trees in split behavior?', 'B*-Trees distribute data between neighboring nodes until both siblings are full, then split two nodes into three nodes that are each two-thirds full. This improves average occupancy compared to standard half-empty splits.'),
  (6, 'What is the fastpath optimization for monotonically increasing keys?', 'When inserted keys are strictly greater than all existing keys (auto-increment), inserts always go to the rightmost leaf. PostgreSQL and SQLite skip the read path by caching the rightmost page, enabling direct insertion.'),
  (6, 'What is bulk loading in B-Trees?', 'Building a B-Tree from presorted data by writing leaf pages sequentially and composing the tree bottom-up. Avoids splits and merges entirely, keeps only minimal tree structure in memory, and allows complete page fill for immutable trees.'),
  (6, 'What are the trade-offs of B-Tree compression?', 'Better compression improves data size and allows fetching more data per access, but requires more RAM and CPU for compression/decompression. Page-wise compression is practical as pages can be processed independently.'),
  (6, 'What is page fragmentation in B-Trees?', 'When freed bytes from deletes and updates are scattered across a page rather than contiguous. The page may have enough logical space but not enough contiguous space for new writes, requiring defragmentation.'),
  (6, 'What is the difference between live and garbage data in B-Trees?', 'Live (addressable) data can be reached by following pointers from the root. Garbage (nonaddressable) data includes deleted or overwritten cells that still exist on the page but have no pointers to them.'),
  (6, 'What does page defragmentation (vacuum/compaction) do?', 'Reclaims space occupied by dead cells, rewrites cells in logical order, and may relocate pages. Unused pages return to the page cache; freed disk pages are added to the free page list (freelist).');

-- Add more flashcards for Chapter 6 (module 8 on remote)
INSERT INTO flashcards (module_id, front, back) VALUES
  (8, 'What is copy-on-write in B-Trees?', 'A technique where modified pages are copied rather than updated in place. A parallel tree hierarchy is created with the copied pages, and the topmost pointer is atomically updated when complete. Readers need no synchronization since pages are immutable.'),
  (8, 'What are the advantages of copy-on-write B-Trees?', 'Readers require no synchronization (pages are immutable). Readers do not block writers. No page can be observed in an incomplete state. System crashes cannot corrupt pages since pointer is switched only after all modifications are done.'),
  (8, 'How does LMDB use copy-on-write?', 'LMDB maintains only two root versions (latest and the one being committed). All writes go through the root node. After a new root is created, the old one becomes unavailable for new operations. Old pages are reclaimed when concurrent reads complete.'),
  (8, 'What are lazy B-Trees?', 'B-Tree variants that buffer updates in lightweight, concurrency-friendly in-memory structures and propagate them with delay. This reduces costs of updating the B-Tree by batching writes rather than performing immediate disk I/O.'),
  (8, 'How does WiredTiger implement lazy B-Trees?', 'It uses different formats for in-memory and on-disk pages. Updates are saved to skiplist-based update buffers. During reads, buffer contents merge with disk data. When flushed, updates are reconciled with page contents and persisted, potentially triggering splits.'),
  (8, 'What is the LA-Tree (Lazy-Adaptive Tree)?', 'A B-Tree variant that groups nodes into subtrees and attaches update buffers to each subtree. Inserts go to the root buffer first. When buffers fill, changes cascade down through levels until reaching leaf nodes where batch updates occur.'),
  (8, 'What problem do FD-Trees solve?', 'Random write I/O in B-Trees. FD-Trees limit random writes to a small mutable head tree. When it fills, contents transfer to immutable sorted runs. Runs merge between levels, gradually propagating data from upper to lower levels.'),
  (8, 'What is fractional cascading?', 'A technique to reduce search costs across multiple sorted arrays. After finding an item in the first array (log n steps), subsequent searches start from the closest match in the previous level. Bridges between levels minimize gaps.'),
  (8, 'What are the three main problems Bw-Trees address?', '1) Write amplification - updates require rewriting entire pages. 2) Space amplification - reserving extra space for future updates. 3) Concurrency complexity - dealing with latches.'),
  (8, 'How do Bw-Trees represent nodes?', 'As logical entities consisting of a base node plus delta nodes (modifications) forming a linked list chain. Updates prepend new delta nodes without rewriting existing data. A mapping table translates logical IDs to physical disk locations.'),
  (8, 'How does Bw-Tree achieve lock-free concurrency?', 'By using compare-and-swap (CAS) operations on the mapping table instead of latches. When installing a new delta, the thread atomically updates the mapping table. If two threads compete, one succeeds and the other retries.'),
  (8, 'What is epoch-based reclamation in Bw-Trees?', 'A garbage collection technique that preserves removed nodes/deltas until all readers that started during or before that epoch finish. Later readers never saw those nodes (they were unaddressable), so they can be safely collected.'),
  (8, 'What are cache-oblivious B-Trees?', 'Data structures that give asymptotically optimal performance regardless of memory hierarchy parameters (cache sizes, block sizes, etc.). They work optimally on any machine without parameter tuning by working at the highest cache level as much as possible.'),
  (8, 'What is the van Emde Boas layout?', 'A memory layout that splits trees at middle level edges, recursively creating subtrees of sqrt(N) size. Logically grouped nodes are placed contiguously in memory, optimizing cache performance without knowing specific cache parameters.'),
  (8, 'What is a packed array in cache-oblivious B-Trees?', 'A contiguous memory structure with gaps reserved for future inserts based on density thresholds. Items are relocated only to create gaps for new elements. The structure rebuilds when becoming too dense or sparse.'),
  (8, 'What is write amplification in B-Trees?', 'The overhead of rewriting entire pages for small updates. A single byte change requires rewriting the full page. Lazy B-Trees and Bw-Trees reduce this by buffering updates or using append-only storage.'),
  (8, 'What is space amplification in B-Trees?', 'The overhead of reserving extra space in nodes for future writes. Pages are not fully packed to allow in-place updates. Immutable structures like FD-Trees and Bw-Trees avoid this by not reserving space for modifications.');
